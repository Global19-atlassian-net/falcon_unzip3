
import json
import os
#import snakemake.utils

def snake_merge_dynamic_dict(reldir, input_fns, pattern, wildcards):
        '''Assume each wildcard appears at most once in the pattern.
        '''
        for k in wildcards:
            pattern = pattern.replace('{%s}' %k, '(?P<%s>\w+)' %k)
        re_dynamic = re.compile(pattern)
        mapped = list()
        for fn in input_fns:
            mo = re_dynamic.search(fn)
            assert mo, '{!r} did not match {!r}'.format(fn, re_dynamic.pattern)
            file_description = dict()
            file_description['wildcards'] = dict(mo.groupdict())
            file_description['fn'] = os.path.relpath(fn, reldir)
            mapped.append(file_description)
        return mapped

def snake_merge_multi_dynamic(output_fn, dict_of_input_fns, dict_of_patterns, wildcards):
        outdir = os.path.normpath(os.path.dirname(output_fn))
        if not os.path.isdir(outdir):
            os.makedirs(outdir)
        assert list(sorted(dict_of_input_fns.keys())) == list(sorted(dict_of_patterns.keys()))
        all_mapped = dict()
        for i in dict_of_patterns.keys():
            input_fns = dict_of_input_fns[i]
            pattern = dict_of_patterns[i]
            mapped = snake_merge_dynamic_dict(outdir, input_fns, pattern, wildcards)
            all_mapped[i] = mapped
        all_grouped = dict()
        for i, mapped in all_mapped.items():
            #print(i, mapped)
            for file_description in mapped:
                #print(file_description)
                #print(file_description['wildcards'])
                #print(list(sorted(file_description['wildcards'].items())))
                wildkey = ','.join('{}={}'.format(k,v) for k,v in sorted(file_description['wildcards'].items()))
                if wildkey not in all_grouped:
                    new_group = dict(
                        wildcards=dict(file_description['wildcards']),
                        fns=dict(),
                    )
                    all_grouped[wildkey] = new_group
                group = all_grouped[wildkey]
                wildcards = file_description['wildcards']
                assert wildcards == group['wildcards'], '{!r} should match {!r} by snakemake convention'.format(
                    wildcards, group['wildcards'])
                fn = file_description['fn']
                group['fns'][i] = fn
        ser = json.dumps(all_grouped, indent=2, separators=(',', ': ')) + '\n'
        with open(output_fn, 'w') as out:
            out.write(ser)

shell.prefix('''
set -vx
hostname
pwd
''')

rule static_3_unzip_reads_dump_rawread_ids:
    input:  rawread_db='0-rawreads/raw_reads.db', falcon_asm_done='2-asm-falcon/falcon_asm_done'
    output: rawread_id_file='3-unzip/reads/dump_rawread_ids/rawread_ids'
    params:
        topdir="../../.."
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

DBshow -n ../../../{input.rawread_db} | tr -d '>' | LD_LIBRARY_PATH= awk '{{print $1}}' > ../../../{output.rawread_id_file}

date
'''

rule static_3_unzip_reads_dump_pread_ids:
    input:  pread_db='1-preads_ovl/preads.db', falcon_asm_done='2-asm-falcon/falcon_asm_done'
    output: pread_id_file='3-unzip/reads/dump_pread_ids/pread_ids'
    params:
        topdir="../../.."
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

DBshow -n ../../../{input.pread_db} | tr -d '>' | LD_LIBRARY_PATH= awk '{{print $1}}' > ../../../{output.pread_id_file}

date
'''

rule static_3_unzip_reads_get_read_ctg_map:
    input:  rawread_id_file='3-unzip/reads/dump_rawread_ids/rawread_ids', pread_id_file='3-unzip/reads/dump_pread_ids/pread_ids', ctg_paths='2-asm-falcon/ctg_paths', utg_data='2-asm-falcon/utg_data', sg_edges_list='2-asm-falcon/sg_edges_list'
    output: read_to_contig_map='3-unzip/reads/get_read_ctg_map/read_to_contig_map'
    params:
        topdir="../../.."
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

python -m falcon_kit.mains.generate_read_to_ctg_map --rawread-id=../../../{input.rawread_id_file} --pread-id=../../../{input.pread_id_file} --sg-edges-list=../../../{input.sg_edges_list} --utg-data=../../../{input.utg_data} --ctg-paths=../../../{input.ctg_paths} --output=../../../{output.read_to_contig_map}

date
'''

rule static___3_unzip_reads:
    input:  fofn='input.fofn', read_to_contig_map='3-unzip/reads/get_read_ctg_map/read_to_contig_map'
    output: ctg_list_file='3-unzip/reads/ctg_list', job_done='3-unzip/reads/track_reads_done'
    params:
        topdir="../..",
        sge_option="-pe smp 12 -q default"
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

# Also require read_to_contig_map.
python -m falcon_unzip.mains.rr_ctg_track --base-dir={params.topdir} --output=rawread_to_contigs
python -m falcon_unzip.mains.pr_ctg_track --base-dir={params.topdir} --output=pread_to_contigs
# Those outputs are used only by fetch_reads.
python -m falcon_unzip.mains.fetch_reads --base-dir={params.topdir} --fofn=../../{input.fofn} --ctg-list=../../{output.ctg_list_file}
touch ../../{output.job_done}

date
'''

rule static___3_unzip_1_hasm_scattered:
    input:  ctg_list='3-unzip/reads/ctg_list'
    output: scattered='3-unzip/1-hasm/scattered/scattered.json'
    params:
        topdir="../../.."
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

python -m falcon_unzip.mains.phasing_scatter --ctg-list-fn=../../../{input.ctg_list} --scattered-fn=../../../{output.scattered}

date
'''

rule dynamic_foo_split:
    input:  '3-unzip/1-hasm/scattered/scattered.json'
    output: read_fasta=dynamic('3-unzip/reads/{ctg_id}.symlink/reads.fa'), ref_fasta=dynamic('3-unzip/reads/{ctg_id}.symlink/ref.fa')
    shell: 'python -m falcon_unzip.mains.symlink_mapped --special-split={input} read_fasta="./3-unzip/reads/{{ctg_id}}.symlink/reads.fa" ref_fasta="./3-unzip/reads/{{ctg_id}}.symlink/ref.fa"'

rule static___3_unzip_0_phasing__ctg_id_:
    input:  read_fasta='3-unzip/reads/{ctg_id}.symlink/reads.fa', ref_fasta='3-unzip/reads/{ctg_id}.symlink/ref.fa'
    output: rid_to_phase_out='3-unzip/0-phasing/{ctg_id}/rid_to_phase'
    params:
        sge_option="-pe smp 24 -q bigmem",
        ctg_id="{ctg_id}"
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date


# BLASR
ctg_aln_out='blasr/{params.ctg_id}_sorted.bam'
mkdir -p blasr
time blasr ../../../{input.read_fasta} ../../../{input.ref_fasta} --noSplitSubreads --clipping subread --hitPolicy randombest --randomSeed 42 --bestn 1 --minPctIdentity 70.0 --minMatch 12  --nproc 24 --bam --out tmp_aln.bam
#samtools view -bS tmp_aln.sam | samtools sort - {params.ctg_id}_sorted
samtools sort tmp_aln.bam -o ${{ctg_aln_out}}
samtools index ${{ctg_aln_out}}
rm tmp_aln.bam

bam_fn=${{ctg_aln_out}}
fasta_fn=../../../{input.ref_fasta}

# MAKE_HET_CALL
vmap_fn='het_call/variant_map'
vpos_fn='het_call/variant_pos'
q_id_map_fn='het_call/q_id_map.msgpack'
mkdir -p het_call
python -m falcon_unzip.mains.phasing_make_het_call --bam ${{bam_fn}} --fasta ${{fasta_fn}} --ctg-id {params.ctg_id} --vmap=${{vmap_fn}} --vpos=${{vpos_fn}} --q-id-map=${{q_id_map_fn}}

# GENERATE ASSOCIATION TABLE
atable_fn='g_atable/atable'
mkdir -p g_atable
python -m falcon_unzip.mains.phasing_generate_association_table --ctg-id {params.ctg_id} --vmap=${{vmap_fn}} --atable=${{atable_fn}}

# GET PHASED BLOCKS
phased_variant_fn='get_phased_blocks/phased_variants'
mkdir -p get_phased_blocks
python -m falcon_unzip.mains.phasing_get_phased_blocks --vmap=${{vmap_fn}} --atable=${{atable_fn}} --p-variant=${{phased_variant_fn}}

# GET PHASED READS
phased_reads_fn='get_phased_reads/phased_reads'
mkdir -p get_phased_reads
python -m falcon_unzip.mains.phasing_get_phased_reads --ctg-id={params.ctg_id} --vmap=${{vmap_fn}} --p-variant=${{phased_variant_fn}} --q-id-map=${{q_id_map_fn}} --phased-reads=${{phased_reads_fn}}

# PHASING READMAP
# TODO: read-map-dir/* as inputs
python -m falcon_unzip.mains.phasing_readmap --the-ctg-id={params.ctg_id} --read-map-dir=../../reads --phased-reads=${{phased_reads_fn}} >| ../../../{output.rid_to_phase_out}.tmp
mv ../../../{output.rid_to_phase_out}.tmp ../../../{output.rid_to_phase_out}

date
'''

rule dynamic_foo_merge:
    input:  rid_to_phase_out=ancient(dynamic('3-unzip/0-phasing/{ctg_id}/rid_to_phase'))
    output: '3-unzip/1-hasm/gathered-rid-to-phase/gathered.json'
    run:
        snake_merge_multi_dynamic(output[0],
            dict(
              rid_to_phase_out=[str(i) for i in input.rid_to_phase_out]
            ),
            dict(
              rid_to_phase_out="3-unzip/0-phasing/{ctg_id}/rid_to_phase"
            ),
            ["ctg_id"] # all wildcards
        )

rule static___3_unzip_1_hasm_concatenated_rid_to_phase:
    input:  gathered='3-unzip/1-hasm/gathered-rid-to-phase/gathered.json'
    output: rid_to_phase_all='3-unzip/1-hasm/concatenated-rid-to-phase/rid_to_phase.all'
    params:
        topdir="../../.."
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

python -m falcon_unzip.mains.phasing_gather --gathered=../../../{input.gathered} --rid-to-phase-all=../../../{output.rid_to_phase_all}

date
'''

rule static___3_unzip_1_hasm:
    input:  las_fofn='1-preads_ovl/merged-las-fofn/las.fofn', rid_to_phase_all='3-unzip/1-hasm/concatenated-rid-to-phase/rid_to_phase.all'
    output: job_done='3-unzip/1-hasm/hasm_done'
    params:
        topdir="../..",
        sge_option="-pe smp 48 -q bigmem"
    shell:
        '''
outdir=$(dirname {output[0]})
#mkdir -p ${{outdir}}
cd ${{outdir}}
date

python -m falcon_unzip.mains.ovlp_filter_with_phase --fofn ../../{input.las_fofn} --max_diff 120 --max_cov 120 --min_cov 1 --n_core 48 --min_len 2500 --db ../../1-preads_ovl/preads.db --rid_phase_map ../../{input.rid_to_phase_all} > preads.p_ovl
python -m falcon_unzip.mains.phased_ovlp_to_graph preads.p_ovl --min_len 2500 > fc.log
if [ -e ../../1-preads_ovl/preads4falcon.fasta ];
then
  ln -sf ../../1-preads_ovl/preads4falcon.fasta .
else
  ln -sf ../../1-preads_ovl/db2falcon/preads4falcon.fasta .
fi
python -m falcon_unzip.mains.graphs_to_h_tigs --fc_asm_path ../../2-asm-falcon/ --fc_hasm_path ./ --ctg_id all --rid_phase_map ../../{input.rid_to_phase_all} --fasta preads4falcon.fasta

# more script -- a little bit hacky here, we should improve

WD=$PWD
for f in `cat ../reads/ctg_list `; do mkdir -p $WD/$f; cd $WD/$f; python -m falcon_unzip.mains.dedup_h_tigs $f; done

## prepare for quviering the haplotig
cd $WD/..

find 0-phasing -name "phased_reads" | sort | xargs cat >| all_phased_reads
find 1-hasm -name "h_ctg_ids.*" | sort | xargs cat >| all_h_ctg_ids
find 1-hasm -name "p_ctg_edges.*" | sort | xargs cat >| all_p_ctg_edges
find 1-hasm -name "h_ctg_edges.*" | sort | xargs cat >| all_h_ctg_edges
find 1-hasm -name "p_ctg.*.fa" | sort | xargs cat >| all_p_ctg.fa
find 1-hasm -name "h_ctg.*.fa" | sort | xargs cat >| all_h_ctg.fa

# Generate a GFA for only primary contigs and haplotigs.
time python -m falcon_unzip.mains.unzip_gen_gfa_v1 --unzip-root $WD/.. --p-ctg-fasta $WD/../all_p_ctg.fa --h-ctg-fasta $WD/../all_h_ctg.fa --preads-fasta $WD/preads4falcon.fasta >| $WD/../asm.gfa

# Generate a GFA of all assembly graph edges. This GFA can contain
# edges and nodes which are not part of primary contigs and haplotigs
time python -m falcon_unzip.mains.unzip_gen_gfa_v1 --unzip-root $WD/.. --p-ctg-fasta $WD/../all_p_ctg.fa --h-ctg-fasta $WD/../all_h_ctg.fa --preads-fasta $WD/preads4falcon.fasta --add-string-graph >| $WD/../sg.gfa

cd $WD
touch ../../{output.job_done}

date
'''
